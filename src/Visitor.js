/* @flow */

/**
 * NOTE: This file is automatically generated. To edit:
 * - modify types.json to update the types generated by decaffeinate-parser
 * - run `npm run flow && npm test` to check your work
 */

import BasicVisitor from './BasicVisitor.js';
import type { ArrayInitialiser, AssignOp, BitAndOp, BitNotOp, BitOrOp, BitXorOp, Block, Bool, BoundFunction, Break, ChainedComparisonOp, Class_, ClassProtoAssignOp, CompoundAssignOp, Conditional, Constructor, Continue, DefaultParam, DeleteOp, DivideOp, DoOp, DynamicMemberAccessOp, EQOp, ExistsOp, ExpOp, Expansion, Expression, ExtendsOp, Float, FloorDivideOp, ForIn, ForOf, Function_, FunctionApplication, GeneratorFunction, GTEOp, GTOp, Herestring, Identifier, InOp, InstanceofOp, Int, JavaScript, LTEOp, LTOp, LeftShiftOp, LogicalAndOp, LogicalNotOp, LogicalOrOp, MemberAccessOp, MultiplyOp, NEQOp, NewOp, Node, Null, ObjectInitialiser, ObjectInitialiserMember, OfOp, PlusOp, PostDecrementOp, PostIncrementOp, PreDecrementOp, PreIncrementOp, Program, ProtoMemberAccessOp, Range, RegExp, RemOp, Rest, Return, SeqOp, SignedRightShiftOp, Slice, SoakedDynamicMemberAccessOp, SoakedFunctionApplication, SoakedMemberAccessOp, Spread, Statement, String, SubtractOp, Super, Switch, SwitchCase, TemplateLiteral, This, Throw, Try, TypeofOp, UnaryExistsOp, UnaryNegateOp, UnaryPlusOp, Undefined, UnsignedRightShiftOp, While, Yield, YieldFrom, Functions, Assignee, Parameter } from './types.js';

/**
 * Implements the visitor pattern for decaffeinate-parser ASTs.
 */
export default class Visitor extends BasicVisitor {
  visitNode(node: Node) {
    switch (node.type) {
      case 'ArrayInitialiser':
        this.visitArrayInitialiser(node);
        break;

      case 'AssignOp':
        this.visitAssignOp(node);
        break;

      case 'BitAndOp':
        this.visitBitAndOp(node);
        break;

      case 'BitNotOp':
        this.visitBitNotOp(node);
        break;

      case 'BitOrOp':
        this.visitBitOrOp(node);
        break;

      case 'BitXorOp':
        this.visitBitXorOp(node);
        break;

      case 'Block':
        this.visitBlock(node);
        break;

      case 'Bool':
        this.visitBool(node);
        break;

      case 'BoundFunction':
        this.visitBoundFunction(node);
        break;

      case 'Break':
        this.visitBreak(node);
        break;

      case 'ChainedComparisonOp':
        this.visitChainedComparisonOp(node);
        break;

      case 'Class':
        this.visitClass(node);
        break;

      case 'ClassProtoAssignOp':
        this.visitClassProtoAssignOp(node);
        break;

      case 'CompoundAssignOp':
        this.visitCompoundAssignOp(node);
        break;

      case 'Conditional':
        this.visitConditional(node);
        break;

      case 'Constructor':
        this.visitConstructor(node);
        break;

      case 'Continue':
        this.visitContinue(node);
        break;

      case 'DefaultParam':
        this.visitDefaultParam(node);
        break;

      case 'DeleteOp':
        this.visitDeleteOp(node);
        break;

      case 'DivideOp':
        this.visitDivideOp(node);
        break;

      case 'DoOp':
        this.visitDoOp(node);
        break;

      case 'DynamicMemberAccessOp':
        this.visitDynamicMemberAccessOp(node);
        break;

      case 'EQOp':
        this.visitEQOp(node);
        break;

      case 'ExistsOp':
        this.visitExistsOp(node);
        break;

      case 'ExpOp':
        this.visitExpOp(node);
        break;

      case 'Expansion':
        this.visitExpansion(node);
        break;

      case 'ExtendsOp':
        this.visitExtendsOp(node);
        break;

      case 'Float':
        this.visitFloat(node);
        break;

      case 'FloorDivideOp':
        this.visitFloorDivideOp(node);
        break;

      case 'ForIn':
        this.visitForIn(node);
        break;

      case 'ForOf':
        this.visitForOf(node);
        break;

      case 'Function':
        this.visitFunction(node);
        break;

      case 'FunctionApplication':
        this.visitFunctionApplication(node);
        break;

      case 'GeneratorFunction':
        this.visitGeneratorFunction(node);
        break;

      case 'GTEOp':
        this.visitGTEOp(node);
        break;

      case 'GTOp':
        this.visitGTOp(node);
        break;

      case 'Herestring':
        this.visitHerestring(node);
        break;

      case 'Identifier':
        this.visitIdentifier(node);
        break;

      case 'InOp':
        this.visitInOp(node);
        break;

      case 'InstanceofOp':
        this.visitInstanceofOp(node);
        break;

      case 'Int':
        this.visitInt(node);
        break;

      case 'JavaScript':
        this.visitJavaScript(node);
        break;

      case 'LTEOp':
        this.visitLTEOp(node);
        break;

      case 'LTOp':
        this.visitLTOp(node);
        break;

      case 'LeftShiftOp':
        this.visitLeftShiftOp(node);
        break;

      case 'LogicalAndOp':
        this.visitLogicalAndOp(node);
        break;

      case 'LogicalNotOp':
        this.visitLogicalNotOp(node);
        break;

      case 'LogicalOrOp':
        this.visitLogicalOrOp(node);
        break;

      case 'MemberAccessOp':
        this.visitMemberAccessOp(node);
        break;

      case 'MultiplyOp':
        this.visitMultiplyOp(node);
        break;

      case 'NEQOp':
        this.visitNEQOp(node);
        break;

      case 'NewOp':
        this.visitNewOp(node);
        break;

      case 'Null':
        this.visitNull(node);
        break;

      case 'ObjectInitialiser':
        this.visitObjectInitialiser(node);
        break;

      case 'ObjectInitialiserMember':
        this.visitObjectInitialiserMember(node);
        break;

      case 'OfOp':
        this.visitOfOp(node);
        break;

      case 'PlusOp':
        this.visitPlusOp(node);
        break;

      case 'PostDecrementOp':
        this.visitPostDecrementOp(node);
        break;

      case 'PostIncrementOp':
        this.visitPostIncrementOp(node);
        break;

      case 'PreDecrementOp':
        this.visitPreDecrementOp(node);
        break;

      case 'PreIncrementOp':
        this.visitPreIncrementOp(node);
        break;

      case 'Program':
        this.visitProgram(node);
        break;

      case 'ProtoMemberAccessOp':
        this.visitProtoMemberAccessOp(node);
        break;

      case 'Range':
        this.visitRange(node);
        break;

      case 'RegExp':
        this.visitRegExp(node);
        break;

      case 'RemOp':
        this.visitRemOp(node);
        break;

      case 'Rest':
        this.visitRest(node);
        break;

      case 'Return':
        this.visitReturn(node);
        break;

      case 'SeqOp':
        this.visitSeqOp(node);
        break;

      case 'SignedRightShiftOp':
        this.visitSignedRightShiftOp(node);
        break;

      case 'Slice':
        this.visitSlice(node);
        break;

      case 'SoakedDynamicMemberAccessOp':
        this.visitSoakedDynamicMemberAccessOp(node);
        break;

      case 'SoakedFunctionApplication':
        this.visitSoakedFunctionApplication(node);
        break;

      case 'SoakedMemberAccessOp':
        this.visitSoakedMemberAccessOp(node);
        break;

      case 'Spread':
        this.visitSpread(node);
        break;

      case 'String':
        this.visitString(node);
        break;

      case 'SubtractOp':
        this.visitSubtractOp(node);
        break;

      case 'Super':
        this.visitSuper(node);
        break;

      case 'Switch':
        this.visitSwitch(node);
        break;

      case 'SwitchCase':
        this.visitSwitchCase(node);
        break;

      case 'TemplateLiteral':
        this.visitTemplateLiteral(node);
        break;

      case 'This':
        this.visitThis(node);
        break;

      case 'Throw':
        this.visitThrow(node);
        break;

      case 'Try':
        this.visitTry(node);
        break;

      case 'TypeofOp':
        this.visitTypeofOp(node);
        break;

      case 'UnaryExistsOp':
        this.visitUnaryExistsOp(node);
        break;

      case 'UnaryNegateOp':
        this.visitUnaryNegateOp(node);
        break;

      case 'UnaryPlusOp':
        this.visitUnaryPlusOp(node);
        break;

      case 'Undefined':
        this.visitUndefined(node);
        break;

      case 'UnsignedRightShiftOp':
        this.visitUnsignedRightShiftOp(node);
        break;

      case 'While':
        this.visitWhile(node);
        break;

      case 'Yield':
        this.visitYield(node);
        break;

      case 'YieldFrom':
        this.visitYieldFrom(node);
        break;

      default:
        throw new Error(`unexpected node type: ${node.type}`);
    }
  }

  visitArrayInitialiser(node: ArrayInitialiser) {
    node.members.forEach(child => this.descend(child));
  }

  visitAssignOp(node: AssignOp) {
    this.descend(node.assignee);
    this.descend(node.expression);
  }

  visitBitAndOp(node: BitAndOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitBitNotOp(node: BitNotOp) {
    this.descend(node.expression);
  }

  visitBitOrOp(node: BitOrOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitBitXorOp(node: BitXorOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitBlock(node: Block) {
    node.statements.forEach(child => this.descend(child));
  }

  visitBool(node: Bool) {
    // no children
  }

  visitBoundFunction(node: BoundFunction) {
    node.parameters.forEach(child => this.descend(child));
    if (node.body) {
      this.descend(node.body);
    }
  }

  visitBreak(node: Break) {
    // no children
  }

  visitChainedComparisonOp(node: ChainedComparisonOp) {
    this.descend(node.expression);
  }

  visitClass(node: Class_) {
    if (node.nameAssignee) {
      this.descend(node.nameAssignee);
    }
    if (node.parent) {
      this.descend(node.parent);
    }
    if (node.body) {
      this.descend(node.body);
    }
  }

  visitClassProtoAssignOp(node: ClassProtoAssignOp) {
    this.descend(node.assignee);
    this.descend(node.expression);
  }

  visitCompoundAssignOp(node: CompoundAssignOp) {
    this.descend(node.assignee);
    this.descend(node.expression);
  }

  visitConditional(node: Conditional) {
    this.descend(node.condition);
    this.descend(node.consequent);
    if (node.alternate) {
      this.descend(node.alternate);
    }
  }

  visitConstructor(node: Constructor) {
    this.descend(node.assignee);
    this.descend(node.expression);
  }

  visitContinue(node: Continue) {
    // no children
  }

  visitDefaultParam(node: DefaultParam) {
    this.descend(node.param);
    this.descend(node.default);
  }

  visitDeleteOp(node: DeleteOp) {
    this.descend(node.expression);
  }

  visitDivideOp(node: DivideOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitDoOp(node: DoOp) {
    this.descend(node.expression);
  }

  visitDynamicMemberAccessOp(node: DynamicMemberAccessOp) {
    this.descend(node.expression);
    this.descend(node.indexingExpr);
  }

  visitEQOp(node: EQOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitExistsOp(node: ExistsOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitExpOp(node: ExpOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitExpansion(node: Expansion) {
    // no children
  }

  visitExtendsOp(node: ExtendsOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitFloat(node: Float) {
    // no children
  }

  visitFloorDivideOp(node: FloorDivideOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitForIn(node: ForIn) {
    if (node.keyAssignee) {
      this.descend(node.keyAssignee);
    }
    if (node.valAssignee) {
      this.descend(node.valAssignee);
    }
    this.descend(node.target);
    if (node.step) {
      this.descend(node.step);
    }
    if (node.filter) {
      this.descend(node.filter);
    }
    this.descend(node.body);
  }

  visitForOf(node: ForOf) {
    this.descend(node.keyAssignee);
    if (node.valAssignee) {
      this.descend(node.valAssignee);
    }
    this.descend(node.target);
    if (node.filter) {
      this.descend(node.filter);
    }
    this.descend(node.body);
  }

  visitFunction(node: Function_) {
    node.parameters.forEach(child => this.descend(child));
    if (node.body) {
      this.descend(node.body);
    }
  }

  visitFunctionApplication(node: FunctionApplication) {
    this.descend(node.function);
    node.arguments.forEach(child => this.descend(child));
  }

  visitGeneratorFunction(node: GeneratorFunction) {
    node.parameters.forEach(child => this.descend(child));
    this.descend(node.body);
  }

  visitGTEOp(node: GTEOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitGTOp(node: GTOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitHerestring(node: Herestring) {
    // no children
  }

  visitIdentifier(node: Identifier) {
    // no children
  }

  visitInOp(node: InOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitInstanceofOp(node: InstanceofOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitInt(node: Int) {
    // no children
  }

  visitJavaScript(node: JavaScript) {
    // no children
  }

  visitLTEOp(node: LTEOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitLTOp(node: LTOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitLeftShiftOp(node: LeftShiftOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitLogicalAndOp(node: LogicalAndOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitLogicalNotOp(node: LogicalNotOp) {
    this.descend(node.expression);
  }

  visitLogicalOrOp(node: LogicalOrOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitMemberAccessOp(node: MemberAccessOp) {
    this.descend(node.expression);
  }

  visitMultiplyOp(node: MultiplyOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitNEQOp(node: NEQOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitNewOp(node: NewOp) {
    this.descend(node.ctor);
    node.arguments.forEach(child => this.descend(child));
  }

  visitNull(node: Null) {
    // no children
  }

  visitObjectInitialiser(node: ObjectInitialiser) {
    node.members.forEach(child => this.descend(child));
  }

  visitObjectInitialiserMember(node: ObjectInitialiserMember) {
    this.descend(node.key);
    this.descend(node.expression);
  }

  visitOfOp(node: OfOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitPlusOp(node: PlusOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitPostDecrementOp(node: PostDecrementOp) {
    this.descend(node.expression);
  }

  visitPostIncrementOp(node: PostIncrementOp) {
    this.descend(node.expression);
  }

  visitPreDecrementOp(node: PreDecrementOp) {
    this.descend(node.expression);
  }

  visitPreIncrementOp(node: PreIncrementOp) {
    this.descend(node.expression);
  }

  visitProgram(node: Program) {
    if (node.body) {
      this.descend(node.body);
    }
  }

  visitProtoMemberAccessOp(node: ProtoMemberAccessOp) {
    this.descend(node.expression);
  }

  visitRange(node: Range) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitRegExp(node: RegExp) {
    // no children
  }

  visitRemOp(node: RemOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitRest(node: Rest) {
    this.descend(node.expression);
  }

  visitReturn(node: Return) {
    if (node.expression) {
      this.descend(node.expression);
    }
  }

  visitSeqOp(node: SeqOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitSignedRightShiftOp(node: SignedRightShiftOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitSlice(node: Slice) {
    this.descend(node.expression);
    if (node.left) {
      this.descend(node.left);
    }
    if (node.right) {
      this.descend(node.right);
    }
  }

  visitSoakedDynamicMemberAccessOp(node: SoakedDynamicMemberAccessOp) {
    this.descend(node.expression);
    this.descend(node.indexingExpr);
  }

  visitSoakedFunctionApplication(node: SoakedFunctionApplication) {
    this.descend(node.function);
    node.arguments.forEach(child => this.descend(child));
  }

  visitSoakedMemberAccessOp(node: SoakedMemberAccessOp) {
    this.descend(node.expression);
  }

  visitSpread(node: Spread) {
    this.descend(node.expression);
  }

  visitString(node: String) {
    // no children
  }

  visitSubtractOp(node: SubtractOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitSuper(node: Super) {
    // no children
  }

  visitSwitch(node: Switch) {
    if (node.expression) {
      this.descend(node.expression);
    }
    node.cases.forEach(child => this.descend(child));
    if (node.alternate) {
      this.descend(node.alternate);
    }
  }

  visitSwitchCase(node: SwitchCase) {
    node.conditions.forEach(child => this.descend(child));
    this.descend(node.consequent);
  }

  visitTemplateLiteral(node: TemplateLiteral) {
    node.quasis.forEach(child => this.descend(child));
    node.expressions.forEach(child => this.descend(child));
  }

  visitThis(node: This) {
    // no children
  }

  visitThrow(node: Throw) {
    this.descend(node.expression);
  }

  visitTry(node: Try) {
    this.descend(node.body);
    if (node.catchAssignee) {
      this.descend(node.catchAssignee);
    }
    if (node.catchBody) {
      this.descend(node.catchBody);
    }
    if (node.finallyBody) {
      this.descend(node.finallyBody);
    }
  }

  visitTypeofOp(node: TypeofOp) {
    this.descend(node.expression);
  }

  visitUnaryExistsOp(node: UnaryExistsOp) {
    this.descend(node.expression);
  }

  visitUnaryNegateOp(node: UnaryNegateOp) {
    this.descend(node.expression);
  }

  visitUnaryPlusOp(node: UnaryPlusOp) {
    this.descend(node.expression);
  }

  visitUndefined(node: Undefined) {
    // no children
  }

  visitUnsignedRightShiftOp(node: UnsignedRightShiftOp) {
    this.descend(node.left);
    this.descend(node.right);
  }

  visitWhile(node: While) {
    this.descend(node.condition);
    if (node.guard) {
      this.descend(node.guard);
    }
    this.descend(node.body);
  }

  visitYield(node: Yield) {
    this.descend(node.expression);
  }

  visitYieldFrom(node: YieldFrom) {
    this.descend(node.expression);
  }
}
